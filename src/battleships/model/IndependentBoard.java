/*
 * Copyright (c) 2015. Shen Yichen <2007.yichen@gmail.com>
 * Under The MIT License.
 */

package battleships.model;

import java.util.*;

/**
 * An implementation of Board that calculates probability independently for each {@code Ship}.
 * <p>
 * This board attempts to fit each ship into all possible configurations. The total number is tallied individually for
 * each ship. Total probability is summed up linearly, treating each ship's probability as independent.
 * <p>
 * P{A &#8746; B} = P{A} + P{B} - P{A &#8745; B}
 * <p>
 * Note that this will ignore the fact that a placing of a certain ship invalidates certain positions of another ship .
 * As such there are limitations to the accuracies of the probability derived.
 * <p>
 * Using only the ship placement count map generated by {@code getShipsMatrix()} would generally be preferred.
 *
 * @author Shen Yichen <2007.yichen@gmail.com>
 * @see Ship
 * @since v1.0.0
 */
public class IndependentBoard implements Board {

    /**
     * States of a square on the board.
     */
    public enum SquareState {
        /**
         * When square is open and untouched.
         */
        OPEN,
        /**
         * When the square is confirmed to be empty.
         */
        MISS,
        /**
         * When the square is confirmed to be occupied.
         */
        HIT,
        /**
         * When the square is occupied by a sunken ship.
         */
        SUNK
    }

    // <editor-fold desc="Class variables">
    /**
     * For storing the state of the board.
     */
    private SquareState[][] board;
    /**
     * Stores the list of ships.
     */
    private Collection<Ship> ships;
    /**
     * Stores the possible configurations of all ships.
     * <p>
     * Each configuration is given an incremental ID.
     */
    private SortedMap<Integer, Collection<Square>> possibleShipConfigs;
    /**
     * Stores a link from a square to a configuration that affects it.
     */
    private ArrayList<ArrayList<Collection<Integer>>> reverseMap;
    /**
     * Stores a link from ship to configurations involving it.
     */
    private Map<Ship, Collection<Integer>> shipToConfigID;
    /**
     * Stores boards of possible configurations on each square, one for each ship.
     */
    private Map<Ship, Integer[][]> shipCounter;
    /**
     * Stores the total number of configurations for each ship.
     */
    private Map<Ship, Integer> totalCounter;
    // </editor-fold>

    /**
     * Creates a board with given width and height.
     *
     * @param width  The board width in squares
     * @param height The board height in squares
     */
    public IndependentBoard(int width, int height) {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Board width/height must be bigger than 0!");
        }

        board = new SquareState[width][];
        reverseMap = new ArrayList<>(width);
        shipToConfigID = new HashMap<>();

        for (int i = 0; i < board.length; i++) {
            board[i] = new SquareState[height];
            reverseMap.add(new ArrayList<>(height));

            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = SquareState.OPEN;
                //Using array to store reverse mapping indices, change implementation here
                reverseMap.get(i).add(new ArrayList<>());
            }
        }

        shipCounter = new HashMap<>();
        totalCounter = new HashMap<>();

        ships = new ArrayList<>();
        possibleShipConfigs = new TreeMap<>();
    }

    @Override
    public int getWidth() {
        return board.length;
    }

    @Override
    public int getHeight() {
        //Width is guaranteed to be at least 1
        return board[0].length;
    }

    /**
     * Gets the probability matrix for all ships on this board.
     * <p>
     * Each square on the board is given a probability that any ship may occupy that square.
     * <p>
     * Warning: Overall probabilities calculated by this board is linear, and are not exact! It is preferred to use
     * {@code getShipsMatrix()} in this case.
     *
     * @return Probability matrix
     * @see #getShipsMatrix()
     */
    @Override
    public double[][] getProbabilityMatrix() {
        return new double[0][];
    }

    @Override
    public double[][] getProbabilityMatrix(Ship ship) {
        return new double[0][];
    }

    @Override
    public int[][] getShipsMatrix() {
        int[][] sumMatrix = new int[getWidth()][getHeight()];

        for (Ship s : ships) {
            Integer[][] shipMatrix = shipCounter.get(s);

            for (int i = 0; i < shipMatrix.length; i++) {
                Integer[] col = shipMatrix[i];

                for (int j = 0; j < col.length; j++) {
                    sumMatrix[i][j] += col[j];
                }
            }
        }

        return sumMatrix;
    }

    @Override
    public int[][] getShipsMatrix(Ship ship) {
        Integer[][] shipMatrix = shipCounter.get(ship);
        int[][] copyMatrix = new int[getWidth()][getHeight()];

        for (int i = 0; i < shipMatrix.length; i++) {
            Integer[] col = shipMatrix[i];

            for (int j = 0; j < col.length; j++) {
                copyMatrix[i][j] = col[j];
            }
        }

        return copyMatrix;
    }

    @Override
    public void addShip(Ship ship) {
        ships.add(ship);
        shipCounter.put(ship, new Integer[getWidth()][getHeight()]);
        totalCounter.put(ship, 0);
        genMap(ship);
    }

    @Override
    public Collection<Ship> getShips() {
        return new ArrayList<>(ships);
    }

    @Override
    public boolean shipWithinBoard(Ship ship, int x, int y) {
        return x < 0 || x > getWidth() - ship.getBottomRight().getX()
                || y < 0 || y > getHeight() - ship.getBottomRight().getY();
    }

    @Override
    public boolean shipWithinBoard(Ship ship, Square sqr) {
        return shipWithinBoard(ship, sqr.getX(), sqr.getY());
    }

    /**
     * Adds a new configuration to the map, using the squares on ship.
     * <p>
     * This method will use the key supplied as the configuration identifier, but will throw an {@code
     * IllegalArgumentException} if the key is already present in the mappings.
     *
     * @param ship The ship for the config
     * @param key  The key to identify the config
     * @param x    The starting x position of the config
     * @param y    The starting y position of the config
     */
    void addConfig(Ship ship, int key, int x, int y) {
        if (possibleShipConfigs.containsKey(key)) {
            throw new IllegalArgumentException("Config key supplied already exists! key: " + key);
        }

        //Check if ship is within board
        if (shipWithinBoard(ship, x, y)) {
            throw new IllegalArgumentException(String.format(
                    "Ship is not contained within board!\n(x, y): (%d, %d)\nAccepted Range => x: [0, %d], y: [0, %d]",
                    x,
                    y,
                    getWidth() - ship.getBottomRight().getX(),
                    getHeight() - ship.getBottomRight().getY()));
        }

        Collection<Square> coords = new ArrayList<>(ship.numSquares());

        for (Square square : ship) {
            int checkX = x + square.getX();
            int checkY = y + square.getY();

            //Add coords to list
            coords.add(new Square(checkX, checkY));
            //Reverse Map
            reverseMap.get(checkX).get(checkY).add(key);
            //Add to square count
            shipCounter.get(ship)[checkX][checkY]++;
        }

        possibleShipConfigs.put(key, coords);
        shipToConfigID.get(ship).add(key);
        totalCounter.put(ship, totalCounter.get(ship) + 1);
    }

    /**
     * Check if the ship could fit onto the board starting at the specified position, without interference from
     * obstacles.
     *
     * @param ship The ship
     * @param x    The starting x-position
     * @param y    The starting y-position
     * @return {@code true} if the ship can fit, {@code false} if the ship cannot fit
     */
    boolean checkConfig(Ship ship, int x, int y) {
        boolean fits = shipWithinBoard(ship, x, y);

        if (fits) {
            for (Square square : ship) {
                int checkX = x + square.getX();
                int checkY = y + square.getY();

                //TODO Consider cases besides OPEN
                fits &= board[checkX][checkY] == SquareState.OPEN;
            }
        }

        return fits;
    }

    /**
     * Generates mapping for a given ship.
     * <p>
     * This method adds 3 mappings.
     * <p>
     * One giving an incremental index to a fitted configuration coordinate list.
     * <p>
     * One matching squares that are affected by this configuration to the index.
     * <p>
     * And one that matches ships to the index.
     * <p>
     * Make sure {@code shipCounter} and {@code totalCounter} are initialize for the ship before calling.
     *
     * @param ship Ship to generate mapping for.
     */
    private void genMap(Ship ship) {
        Square shipSize = ship.getBottomRight();

        for (int x = 0; x < board.length - shipSize.getX() + 1; x++) {
            SquareState[] col = board[x];
            for (int y = 0; y < col.length - shipSize.getY() + 1; y++) {
                //TODO account for rotation
                //Try each config and add to config list if config is a valid fit
                if (checkConfig(ship, x, y)) {
                    addConfig(ship, possibleShipConfigs.lastKey() + 1, x, y);
                }
            }
        }
    }
}
